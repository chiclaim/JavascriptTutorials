// 注释

// 什么是好的注释
// 1. 描述架构：对组件进行高层次的整体概括，它们如何相互作用、各种情况下的控制流程是什么样的……简而言之 —— 代码的鸟瞰图。
//    有一个专门用于构建代码的高层次架构图，以对代码进行解释的特殊编程语言 UML。绝对值得学习。
// 2. 记录函数的参数和用法
// 3. 为什么任务以这种方式解决？解决方案的注释非常的重要。它们可以帮助你以正确的方式继续开发。
//    写了什么代码很重要。但是为什么 不 那样写可能对于理解正在发生什么更重要。为什么任务是通过这种方式解决的？代码并没有给出答案。
//    如果有很多种方法都可以解决这个问题，为什么偏偏是这一种？尤其当它不是最显而易见的那一种的时候。没有这样的注释的话，就可能会发生下面的情况：
//    a. 你（或者你的同事）打开了前一段时间写的代码，看到它不是最理想的实现方式。
//    b. 你会想：“我当时是有多蠢啊，现在我真是太聪明了”，然后用“更显而易见且正确的”方式重写了一遍。
//    c. ……重写的这股冲动劲是好的。但是在重写的过程中你发现“更显而易见”的解决方案实际上是有缺陷的。你甚至依稀地想起了为什么会这样，因为你很久之前就已经尝试过这样做了。
//       于是你又还原了那个正确的实现，但是时间已经浪费了。
// 4. 代码有哪些巧妙的特性？它们被用在了什么地方？
//    如果代码存在任何巧妙和不显而易见的方法，那绝对需要注释。


// 新手倾向于使用注释来解释“代码中发生了什么”。就像这样：

function complexFunc() {
    // 这里的代码会先做这件事（……）然后做那件事（……）
    // ……谁知道还有什么……
    // complex code ...
}


// 分解函数
// 用一个函数来代替一个代码片段是更好的，就像这样：
function showPrimes(n) {
    nextPrime:
    for (let i = 2; i < n; i++) {

        // 检测 i 是否是一个质数（素数）
        for (let j = 2; j < i; j++) {
            if (i % j == 0) continue nextPrime;
        }

        alert(i);
    }
}

function showPrimes2(n) {

    for (let i = 2; i < n; i++) {
        if (!isPrime(i)) continue;

        alert(i);
    }
}

// 是否是质数
function isPrime(n) {
    for (let i = 2; i < n; i++) {
        if (n % i == 0) return false;
    }

    return true;
}



/**
 * 返回 x 的 n 次幂的值。
 *
 * @param {number} x 要改变的值。
 * @param {number} n 幂数，必须是一个自然数。
 * @return {number} x 的 n 次幂的值。
 */
function pow(x, n) {
    //...
}

